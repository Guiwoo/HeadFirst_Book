# 네 변수를 알라.

## 1. 원시변수 와 레퍼런스

- 원시변수 ? boolean char byte short int long float double

| Type    | Value,Size | Type   | Size     |
| ------- | ---------- | ------ | -------- |
| boolean | true,false | char   | 2^16 (+) |
| byte    | 2^8 (+,-)  | short  | 2^16     |
| int     | 2^32       | long   | 2^64     |
| float   | 2^32       | double | 2^64     |

- float 값을 쓰고싶다면 변수 뒤에 꼭 f 붙이기 ex) float ex_float = 3.14f;
- String 은 아닌가 ? String 은 객체임;

- 큰값 의 유형을 작은 타입에 담을 수 없다.
  - cf) 그 반대는 허용됨
    - `byte b = 8; int a = b;`

## 2. 저 위에 애들이 아닌애들 은 어떻게 변수임 ? 그건 객체임

- 객체가 변수 가 아닌 레퍼런스 변수임 Go 의 pointer 임
- ex> Dog d = new Dog(); d 는 객체가 아닌 객체를 가르키는 레퍼런스 변수
  -cf)Go 로 작성시 이런식으로 Dog d = &Dog{....}

- 변수를 설정하면 도대체 뭐가 변수 안으로 들어갈까 ?

  - byte x = 7 >> (00000111);
  - Dog d = new Dog(); >> &23231598123 사이즈를 알수 있나 ? 객체의 변수 사이즈 다 더하면 그값이 되나 ? idk;
    - 레퍼런스 의 크기는 알수없음 그러나 모든 레퍼런스는 동일한 크기임
    - 그 레퍼런스가 가르키는 객체의 사이즈 는 객체의 사이즈임;
    - 레퍼런스 변수에 대해 증가시키는 것 같은 연산은 불가(c 는 가능);

- 그러면 레퍼런스가 가르키는 객체는 어디있는가 ? => 힙에서 살고있음(가비지컬렉션 기능이 있는 힙);
  - 힙이란 ? 메모리공간임
- ex> Book b = new Book(); Book c = new Book(); - 이러면 b = 메모리주소1, c =메모리주소2, 대상인 아이들은 메모리 힙에 올라가있음

  - Book d = c;
    - 이러면 ? d 는 c의 메모리주소2 를 가져온다; d = 메모리주소2,
  - c=b;
    - 이러면 ? c는 기존메모리 주소를 1로교체한다.
    - 각 레퍼런스 들은 하나의 주소만을 가르킨다.
  - 그래서? b = 메모주리소1, c = 메모리주소1, d= 메모리 주소2;
  - 결과적으로 3레퍼런스 변수, 2객체가 생기는것

  - 가비지컬렉션 기능이 있는힙인데 뭘하는가?
  - 레퍼런스 변수가 없는 객체 들은 가바지 컬렉터 먹잇감 이 된다.
  - 객체를 가르키지 않는 레퍼런스 변수는 ? 기냥 밖에있다 왜? 가비지컬렉션이 있는 힙에 올라가 있지 않아서, null 의값을 가짐

## 3. 배열 은 항상 객체이다.

- 원시 변수를 저장해도 원시배열 이 아닌 원시변수가 들어있는배열
- 객체가 들어있는배열 ? 아니 레퍼런스 변수가 들어있는 배열을 init 해주면 된다
  - 그렇다고 원소별로 객체가 있는것은 아님 왜? 객체를 아직 가르키지 않기 떄문에 null 임
  - ex> Dog pets = new Dog[7]; pets[0] = new Dog(); 이러면 0번 배열은 객체를 가지게 된다 ! 굿

## 4. 레퍼런스 도용 미스테리

### 클래스에 사용할 새로운 메서드, 메모리 효율을 최대한 끌어올릴수 있는 메서드를 만든사람은 누구인가 ?

- 토니코드

```java
Contact [] ca = new Contact[10];
while(x<10){
    ca[x] = new Contact(); x++;
}
// 복잡한 코드
```

- 밥 코드

```java
Contact refc;
while(x<10){
refc = new Contact(); x++;;
}
//복잡한 코드
}
```

- A. 토니임 왜? 토니는 모든 배열안의 레퍼런스 변수들이 객체를 가지고 있음 반면 밥은 한바퀴 돌떄마다 새로운 객체 레퍼런스 변수를 \n사용, 전에 참조하던 레퍼런스를 끊고 새로운 레퍼런스를 연결 => 마지막 레퍼런스 변수만 생존 기껏 객체 10개를 만들고 쓸모가 없어짐
