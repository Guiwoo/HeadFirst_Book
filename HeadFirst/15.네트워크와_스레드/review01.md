# 15 네트워크 와 스레드 연결하는 방법

    - java.net 라이브러리에 들어있는 클래스에서 알아서 처리해줌
    - BufferedReader 에서는 어디서 왔는지 전혀 신경 쓰지 않음
    - 멀티스레딩 기능을 갖춘 채팅클라이언트 완성 해보기.

## 채팅 프로그램 개요

    - 클라이언트에서는 서버에 대해 알아야 한다.
    - 서버에서는 모든 클라이언트에 대해 알아야 한다.

1. 클라이언트가 서벌에 접속한다.
2. 서버에서 접속을 허용 하고 클라이언트를 수신인 목록에 추가합니다.
3. 다른 클라이언트가 서벌에 접소합니다.
4. 클라이언트 A에서 채팅 서비스로 메세지를 보냅니다.
5. 서버에서 메세지를 모든 참가자들에게 보냅니다. (BroadCasting ? 비슷함)

**연결하기, 보내기 ,받기**

- 클라이언트 와 서버사이에서 초기연결을 정립하는 방법
- 서버로 메세지를 보내는 방법
- 서버로부터 메세지를 받는 방법.

**Api의 네트워킹 패지지 덕에 정말 쉽게 구현 가능한 부분 이다.**

### 네트워크 소켓연결을 만듭니다.

    - 다른 시스템에 연결하려면 소켓연결이 필요합니다.
    - Socket 클래스란 두 시스템 사이의 네트워크 연결을 나타내는 객체!

- 두 소프트 웨어는 서로를 인식하고 있어야 하며,
- 상대방과 통신하는 방법 이 필요하다.

```java
Socket chatSocket = new Socket("196.127.0.0.1",5000);
```

- Js 와 go 에서본 socket 시스템 과 매우 유사하게 생김
- 소켓연결시 서버에 대한 ip 주소와 tcp 포트 번호가 필요하다.

### TCP 포트란 ?

    - 서버에 있는 특정 프로그램을 나타내는 16비트 숫자이다.

- 서버에서 돌아가는 특정 소트웨어로의 논리적인 역녈을 나타내기 위한것
- 포트는 0번 부터 65,535번 까지 부여가 가능하다.
- tcp 포트란 물리적인 포트를 의미하는것이 아닌 용도를 구분하는 숫자에 불과하다.
- 0~1023 번사이는 이미 예약된 포트 번호들이 있으니 그이후부터 사용하자.
- 예시

  - 20 번 FTP "파일전송"
  - 23 번 Telnet "원격시스템 제어"
  - 25 번 SMTP "이메일"
  - 37 번 Time
  - 80 번 HTTP
  - 110 번 POP3
  - 443 번 HTTPS

- 포트 의 한 번호에는 하나의 프로그램 만 실행된다.
- IP주소는 마치 시장의 이름이고
- 포트 번호는 그 시장에 있는 특정 가게 이름이다.

### Socket 으로 부터 데이터를 읽으려면 ?

    - BufferedReader 를 이용하면 된다!
    - file 스트림이 아닌 socket 스트림에 연결하면 클리어.

```java
// 서버에 소켓을 연결
Socket chatSocket = new Socket("127.0.0.1",5000);
// 저수준 입력 스트림에 연쇄된 스트림을 만든다.
InputStreamReader stream = new InputStreamReader(chatSocket.getInputStream());
// 만들고 읽기 매우 간단.
BufferedReader reader = new BufferedReader(stream);
String message = reader.readLine()
```

서버 => 바이트 코드 전송 => 문자로 변환 =>버퍼에 저장된 문자 => 클라이언트

- 데이터를 Socket으로 사용할떄는 printWriter 를 사용한다.

```java
//저수준의 연결스트림을 제공하고 객체를 생성 소켓연결에 바로 사용가능.
PrintWriter writer = new PrintWriter(chatSocket.getOutputStream());
writer.println("보낼 메세지 작성 여기다가 ");
writer.print("또다른 메세지 보내기")
```

### DailyAdivceClient

    - 조언 전문가 앱을 만들어 보자
    - 간단한 채팅앱

1. 연결하기

   - 클라이언트에서 버에 연결해 서버로 부터 입력스트림을 받는다.

2. 읽기 - 클라이언트에서 메세지를 읽어온다.
   [코드예시](./DailyAdviceClient.java)

### DailyServer

    - 간단한 서버를 만들어보자.

1. 서버 앱에서 특정포트에 대한 서버소켓을 만든다.
   - (new ServerSocket(4242))4242 를 감시한다.
2. 클라이언트에서 서버 앱으로 Socket을 연결한다.
   - 클라이언트에서는 ip 주소와 포트번호를 알고있다.
3. 서버에서 클라이언트 와 통신하기 위한 새로운 socket 을 만든다.
   - accept() 메소드는 클라이언트에서 socket을 연결할떄 까지 무한정 기다린다.

[코드예시](./DailyAdviceServer.java)

- 서버에서는 클라이언트와 통신하는 방법을 어떻게 알수 있나요 ?
  - 클라이언트에서는 서버의 ip 와 주소를 알고있다. 하지만 서버에서는 어떻게 클라이언트 와 socket 연결을 하고 입력스트림과 출력스트림을 만들수 있을까 ?
  - 서버에서는 그 클라이언트 에 대한 응답을 계속 기다리면서 입력이 오면 보내주는 역할을 한다.

#### 핵심정리

- Socket은 서로다른 물리적인 시스템 두개에서 실행도리 가능성이 있는 사이 의 연결을 나타낸다.
- 클라이언트 서버에서는 tcp와 ip 주소를 알아야 한다.
- 일단 연결이 되고나면 클라이언트는 소켓으로 부터 입력 및 출력 스트림을 얻을 수 있다.저수준 의 연결 스트림이다.
- 서버로 부터 텍스트 데이터를 읽고 싶다면 소켓의 스트림으로부터 inputstreamreader 와 이와 연쇄된 bufferedReader 를 통해 읽기가가능하다.
- 서버로 텍스트 데이터를 보낼떄는 소켓의 출력 스트림에 직접 연쇄 된 printwirter 객체를 만들면 된다.
- 서버에는 특정 포트로 오는 요청을 기다리는 서버 소켓을 사용한다.
- 서버소켓으로 요청이 들어오면 클라이언톼 소켓연결을 함으로써 요청을 수락한다.

[채팅 클라이언트 코드 예시](./SimpleChatClientA.java)

---

#### 스레드

    - 모든것이 연속적을 진행되어 새로운 사용자로 부터 메세지를 받으려면 ?
    - 새로운 스레드 즉 별도의 스택을 새로 만들어야 한다.

**자바에서의 멀티 스레딩**

- 자바에서는 언어자체에 다중 스레딩 기능이 내장되어 있다.
- Thread 의 객체를 만들면 끝이다.
- 단 문제가 있다 스레드로 무언가를 하지않는다면 그스레드는 죽은 스레드이다.

#### 자바에서는 스레드를 여러개 사용할수 있으나 클래스는 단 하나이다.

    - 스레드는 별도의 실행스레드를 가리키는 별도의 호출 스택이다.
    - 스레드는 자바의 클래스이다.
    - 스레드를 만들려면 thread 를 만들어야 한다.

- 스레드는 별도의 실행 스레드를 지칭한다.(별도의 호출스택)
- 호출 스택이 2개 이상 있다는것은 무엇을 의미하는가 ?
  - 여러가지가 동시에 일어나는것처럼 보여준다.(멀티 태스킹)

1. java 에서 main 메소드를 실행
2. 메인에서 스레드를 시작, 새로운 스레드가 시작되면 메인은 잠시대기
3. jvm 에서는 두스레드가 종료될떄 까지 새로운 스레드 와 원래 메인 사이를 왔다갔다 함.

#### 새로운 스레드를 시작하는 방법

1. Runnable 객체를 생성

   - Runnable 은 인터페이스 입니다.

2. Thread를 만들고 그 객체에 Runnable 객체를 전달합니다.
   - 새로운 runnable 객체를 thread 생성자에 전달.
3. Thread 객체를 시작시킨다.
   - start() 메소드를 호출전까지는 아무일도 일어나지 않는다.

- 모든 스레드 에는 할 작업을 정해줘야 합니다. 새로운 스레드에 집어넣을 메소드가 필요하다.
- run() 이것이 runaable 인터페이스 의 이유이다.
  "Runnable 객체오 Thread 객체의 관계는 작업과 일꾼사이의 관계와 같다."

```java
class Test implements Runnable{
    public void runt(){
        this.go();
    };
    public go(){
        domore();
    }
    public domorea(){}
}
```

- 새로 만들어지는 스레드의 세가지 상태
  "새로운 스레드" => 실행 가능한 상태 => 실행중인 상태 !
- 실행 가능한 상태에 스레드가 들어가게 되면 아래 3 단계를 왔다갔다 한다.

  - 실행 가능한 생태
  - 실행 중인 상태
  - 일시적 실행 불가능 상태

- JVM 에서 위 3단계를 스케줄러 에 의해 결정되어 이동된다.

  - 실행중인 코드에서 그스레드를 대기상태로 하라는 명령(sleep())
  - 어떤 메소드를 호출하려하는데 그 객체가 잠겨있는경우 스레드는 잠든다.
  - 다시실행가능한 상태가 될떄까지 일시적실행 불가능 상태로 전환된다.

- **어떤것이 실행되고 어떤것이 실행되지 않는 지에 대한 결정을 모두 스레드 스케줄러가 내린다.**
- **스레드가 어떤 특별한 방식으로 작동할것을 가정하고 프로그램을 만들면 안된다.**

[스케줄러의 불확실성을 보여줄 예제](./ThreadTestDrive.java)

- 왜 결과가 다를까 ?

  - 스케줄러 에 의해 각 스레드간의 스위칭이 일어나기 떄문에

- Thread 객체도 재사용 가능한가요 ? 새로운 작얿을 지정한 다음 start() 메소드를 다시호출해도 재시작 되나요 ?
  - 안됨, run()메소드가 종료되면 그 스레드는 죽은상태 절대로 다시 되살릴수 없다.

### 핵심정리

- 스레드는 자바에서 실행 스레드를 의미
- 자바에서 스레드 마다 각각의 호출스택이 있다 (함수라는 의미)
- 스레드에는 처리할 작업 즉 할일이 있어야 한다.
- runnable 인터페이스에는 메소드 run() 히 들어있고 이것이 새로운 콜스택 제일 아래에 들어간다.
- Jvm 의 스레드 스케줄러에 의해 현재 실행중인 스레드 로 선택받으면 그스레드는 실행중인 상태가 된다. 프로세스가 하나인 프로그램에서는 스레드가 하나밖에 있을수 없다.
- 스레드가 실행중인 상태에서 일시적실행 불능 상태로 옮겨지는 경우도 있다. 스트림으로 부터 들어오는 데이터를 기다리고 있을때 대기상태로 들어갔을때, 객체에 대한 잠금이 해제되기를 기다리고 있을때 스레드가 일시적 실행불능 상태에 들어갈수 있다.
- 스레드 스케줄링은 어떤 특정한 방식으로 작동한다는 보장이 없기떄문에, 모든 스레드가 공평한 실행 기회를 가진다는 생각을 버려야 한다.

[2편가기](./review02.md)
