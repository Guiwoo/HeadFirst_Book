# 네트워크 와 스레드

    - 지난 리뷰 1편 에서 우리는 스레드의 불확실성에 대해 알아 보았다.
    - 이번 리뷰에서 어떻게 해결할수 있는지 그 방법들에 대하여 알아보자.

- [1편 가기](./review01.md)

## 스레드를 대기상태로 전환 시키는 방법

    - 스레드 들이 공평하게 순번을 받게 하려면 ? 주기적으로 대기상태 를 만들어 주면 된다.

- 정적메소드 인 sleep() 을 호출하고 대기 시간을 함수 인자로 보내주기만 하면 그 시간 동안 실행 할수없는 대기상태에 돌입한다.

  - 주의사항
    - Thread.sleep(2000) 을 사용시 항상 try catch 문 으로 InterruputException 에러를 핸들링 해주어야 한다.

- 이렇게 지정된 시간이 지나고 나면 우리 스케줄러 는 언제 우리 스레드를 다시 실행에 올려줄까요 ?
  - 슬립 메소드로 그 시간동안 재워 실행가능 상태가 아닌게 만들어 스케줄러의 선택으로 부터 제외 될수 있다.
  - 그러나 슬립메소드 종료 이후에 바로 실행중인 상태가 되는것은 아니다.
  - 확신을 할수가 없다.
- 단지 sleep() 을 사용해서 실행결과의 예측성을 높이는 방법이다.
  [예제 확인](./TestThreadDrive.java)
- 지난 1편에서 이 코드안의 sleep 메서드가 없어 뒤죽박죽 엉킨 결과물이 종종 나타나곤했다.
- 그러나 sleep 메서드를 사용함으로써 정확한 순서로 매번 동일한 결과를 예측할수 있다.

## 스레드 2개를 만들고 시작하는 방법

    - 스레드 에는 각기 다른 이름이 존재하며, 직접선택해도 되고, 기본이름을 사용해도 된다.
    - 이는 디버깅에 있어 엄청난 강점을 보여주며. 좋은 버그 해결책이 될수 있다.

- [예제 확인](./ThreadNameDriveTest.java)
- 위 예제 코드를 실행 해보면 어떤결과를 얻을까 ?
  - 아무도 확신할수 없는 결과 가 나온다.오직 스케줄러에 의해 결과 가 매번 달라지기 떄문이다.
    -(단 항상 동일한결과 가 나온다면 for 문의 횟수를 늘려 좀더 과부하를 주어보자.)

## 스레드 의 문제점

    - 스레드 떄문에 병행성의 문제가 야기 될수있다.

- 병행성 문제는 경쟁 조건을 불러을이키고, 경쟁조건은 데이터 변조를 유발하고, 변조된 데이터는 버그를 유발한다.
- 한가지 최악의 상황은 바로, 스레드 2개 이상이 서로다른 스택 2개에 실행되는 메소드 에 있는 동일한 객체 의 메서드를 호출하는 문제

## 라이언 모니카 문제

    - 두개 의 객체가 하나의 은행계좌를 공유할떄 생길수 있는 문제를 보여주는 예제

- [예제확인](./RyanAndMonicaJob.java)

  - 1. 라이언이 잔고가 충분한지 확인한다음 잠에 듭니다.
  - 2. 그 동안 모니카가 끼어들어 잔고를 확인하고 잠에 듭니다..
  - 3. 라이언은 잠에서 깨고 돈을 뽑습니다.
  - 4. 모니카가 깨어 잔고를 인출합니다.

- 돈을 2번 인출하여 계좌 의 돈이 없어 모니카는 인출이 불가능합니다.

### 계좌접근 과 관련된 락이 필요합니다.

    1. 계좌 거래 와 관련된 락 이 있고, 열쇠는 하나 누군가 계좌에 접근하기 전까지 락과 함께있다.
    2. 라이언이 은행 계좌를 사용하면 은행계좌 락의 열쇠는 라이언이 쥐고 있는다.
    3. 라이언의 거래가 끝나기 전까지 그 누구도 계좌에 접근할수가 없다.

**Synchronized 키워드** - 동기화된 코드에 접글하려면 스레드가 열쇠를 가지고 있어야 한다는것을 의미.

- 은행 계좌를 잠그는것이라면 어떤것을 잠그는 건가요 ? 객체 메소드 ?
- 락은 객체마다 하나씩 존재한다.
- 객체에 동기화된 메소드가 2개 있다고 해서 같은 메소드에 스레드 2개가 들어간다는 것은 아니다.
- "동기화 의 목적은 데이터 자체를 잠그는것이 아닌 그 데이터를 접근하는 메소드를 동기화시켜 보호하는것!"

### 갱신내용손실 문제(Lost Update Problem)

    - 데이터베이스 분야에서 나온 고전적인 병행성 문제

- [예제코드](./TestSyncDrive.java)

  - 각 스레드에서 마지막으로 갱신한 내용이 손실되었다, 전에 읽은 벨런스 값이 다시 실행중인 원래상태로 올라가
  - 값을 갱신

- 해결방법
  - increment() 함수를 synchronized 시켜 버린다.

### 동기화와 관련된 치명적인 문제.

    - 데드락 만큼 프로그램을 망가뜨리는 것도 없다.

- 스레드 교차상태 서로 상대방 이 필요한 열쇠를 가지고 있어 무한히 대기에 빠지는 상태를 의미한다.

### 핵심정리

- Thread.sleep() 이라는 정적 메소드는 적어도 sleep 메소드에 전달된 인자로 지정한 시간 동안 대기상태로 만든다.
- 모든 스레드는 실행될기회를 부여하기 위한 용도로 sleep을 사용할순 있으나, 그 스레드가 언제 다시 실행 중인 상태로 갈지 보장할수없다.
- setName 메소드를 사용해 스레드에 이름을 부여할수 있다.
- 스레드 두개 이상이 동일한 객체를 접근하는 경우 심각한 문제가 생길수 있다.
- 다른 스레드가 같은 객체의 같은 메소드에 들어가기 전에 끝까지 실행되어야 하는 메소드를 결정
- 스레드 두개가 동시에 하나의 메소드에 들어가는 것을 방지하고 싶다면 synchronized 키워드를 사용
- 모든 객체는 자물쇠를 가지고 있으나 동기화 된 키워드가 있다면,자물쇠는 매우중요한 역할을 수행
- 객체에 동기화된 메소드가 2개가 있어도 열쇠는 여전히 나나 이다.
