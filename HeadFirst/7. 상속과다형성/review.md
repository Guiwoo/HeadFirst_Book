# 객체마을에서의 더 나은 삶

## 상속의 이해

    - 상위클래스를 확장한다. 하위클래스가 상위클래스를 물려 받는다.

- 예제

```java
public class Doctor{
    boolean worksAtHospital;
    void treatPatient(){}
}

public class FamilyDocter extends Doctor{
    boolean makesHouseCalls;
    void giveAdvice(){};
}

public class Surgeon extends Doctor{
    void treatPatient(){}
    void makeIncision(){}
}
```

## 동물 시뮬레이션 프로그램 을 위한 상속트리 설계

    - 다른 어떤 프로그래머들도 언제든지 프로그램에 새로운 종류의 동물을 추가할 수 있게 만들자.

- 1. 공통적인 속성과 행동이 들어있는 객체를 찾자.

- 2. 공통적인 상태 와 행동을 나타내는 클래스를 설계 "Animal"

  - 상태 ? 인스턴스 변수
  - 행동 ? 메서드 를 의미

- 3. 특정 하위클래스 유형에만 적용되는 행동 이 필요한지 결정

  - eat(),makeNoise() 왜 ? 먹는게 다르니깐
  - 이러한 메소드를 오버라이딩 해야하는걸 고려해야함

- 4. 공통적인 행동이 필요한 하위클래스를 두개이상 찾아 추상화 개념을 더 폭넓게 활용 가능한지 찾아보자.

  - wolf 와 dog 에 공통적인 행동 , lion cat tiger 에도 공통적인 행동

- 5. 클래스 계층 구조를 완성.
  - 개과 동물 고양이과 동물 등 동물 아래로 파생 시켜 클래스를 확장한다.

## 어떤 메소드가 호출 될까 ?

    - 가장 아래있는것이 호출된다 "최신 클래스 에서 적용한 메서드가 호출된다."

- Wolf w = new Wolf();
- w.makNoise(); "wolf 클래스에서 오버라이드 했으니깐 wolf 클래스에서 호출"
- w.roam(); "Canine 클래스에서 마지막으로 오버라이드 했으니 Canine 클래스에서 호출"
- w.eat(); "Wolf 클래스에서 오버라이드 했으니깐 wolf 클래스에서 호출"
- w.sleep(); "Animal 에서 메서드 선언후 오버리이드 된적없으니 animal 클래스에서 호출 !!"

## 'A는 B다' 와 'A 에는 B가 있다' 를 잘 활용하자.

    - 형식을 제대로 설계했는지 알고싶다 ? 'A는 B다 관계가 성립되는지 확인하자.'
    - 어떤 하위클래스 를 골라도 상위클래스 와 의 관계는 성립해야함.

- A<B<C 라는 상속 관계를 가진다고할때
- C는 A다, 의 관계 도 성립이 되어야함.

  - 단 방향은 하나의 방향만 성립이됨 아래에서 위로.

- 상위클래스에서 하위클래스 메소드 쓰고싶으면 어떻게 ?

  - 상위클래스에서 하위클래스에 대해 알필요가 없음. 보통 자식이 부모에게 상속받지 ,부모가 자식에게 상속을 받지는 않음

- 하위클레스에서 상위클래스의 메소드 버전을 완전히 버리지 않고 리뉴얼 하고자 한다면 ?
  - 메소드 오바리이드 를 할떄 super().메소드 를 작성하여 확장 가능함.
    - 그렇다면 위의 케이스 일떄 상위 클래스의 .메소드 와 하위클래스의 .메소드 는 같은가 ? 다름 메소드를 오버라이드 했으니깐

## 상속을 활용하여 설계할떄 주의점.

    - 상속 의 관계 에있어 성립이 안될시 상속을 하면안됨.

- ex) Alram 이라는 클래스에 출력코드가 있음, Piano 에서도 그출력이 필요하여 상속한다 ?
  - 미친짓임.

## 핵심정리

- 하위클래스는 상위클래스를 확장한다.
- 하위 클래스는 상위클래스 의 모든 public 을 상속한다.(private 은 안한다.)
- 메소드는 오버라이드 가능하나 인스턴스변수는 안됨(오버라이드가 아니라 재정의 하는것임 다름).
- 'A 는 B다를 잘 활용하자.'
- 'A 는 B다.' 의 관계는 쌍방향이 아닌 한방향으로만 작동 "하마는 동물이지만 모든 동물이 하마는 아닌것".
- 하위클래스에서 메소드를 오버라이드 하고, 하위클래스 인스턴스에 메소드를 호출하면 오버라이드된 최신 메소드가 호출됨.

## 상속의 장점

    - 코드가 중복되는것을 방지할수 있다.
    - 일련의 클래스를 위한 공통적인 규악을 정의한다.
    - 하위클래스 건드릴필요없이 그냥 상위클래스 업데이트 하면딤.

- 공통적인 코드를 한군데 모아놓고 하위클래스에 상속이 되기 떄문에 코드의 중복을 방지할수 있음.
- 상위클래스에서 메소드를 정의 하는 순간 일종의 계약을 맺는것.

  - "내 형식에 속하는 모든 하위클래스는 다음과 같은 메소드를 써서 이런일을 할수 있다."

- 다형성을 사용하면 레퍼런스 유형을 실제 객체유형의 상위클래스로 지정이 가능함.

```java
Animal[] animals = new Animal[2];
animals[0] = new Dog();
animals[1] = new Cat();
```

- 인자와 리턴유형에 대해서도 다형성을 적용가능함

```java
class Vet {
    public void giveShot(Animal a){
        a.makeNoise();
    }
}
class PetOwner{
    void start(){
        Vet v = new Vet();
        Dog d = new Dog();
        Cat c = new Cat();
        v.giveShot(d);
        v.giveShot(c);
    }
}
```

- 이와같은 다형성을 활용하면 새로운 하위클래스 형식을 프로그램에 추가하더라도 코드를 굳이 바꿀 필요가 없음.

- 하위클래스의 단계 실질적인 제한 이 있나요?얼마나 깊이 들어가나요 ?

  - 보통 두단계 정도 내려가는것으로 설계,그러나 한계는 없음.

- 클래스 의 소스 코드를 못바꾸는 경우 상속해서 오버라이드 해서 더나은 코드작성이 가능한가?

  - 가능함

- final 클래스를 같은것을 못만드는가?
  - 만들수 있음, String 같은애들이 그런 클래스.

## 계약 지키키 : 오버라이드 규칙

    - 메소드는 계약서 입니다 인자는 똑같아야 하고 리턴 유형은 호환 가능 해야한다.
    - 메소드를 더 접근하기 어렵게 만들면 안 됩니다.
    - 접근제어자는 변경 불가.

## 메소드 오버로딩

    - 이름이 같고 인자목록이 다른것 !! 다형성과 전혀관계없음 애는
    - 리턴유형이 달라도됩니다.
    - 리턴 유형만 바꿀수는 없다.
    - 접근단계를 마음대로 바꿀수 있다.
