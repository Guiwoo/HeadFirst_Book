# 객체의 삶과 죽음

    - 객체는 태어나고 죽는다. "가비지 컬렉터 에게 먹힌다."
    - 객체에게 정을 주지말자 😭.

## 스택과 힙 : 삶의 공간

- 스택? 힙 ?
  - 자바 는 2가지의 메모리 공간을 다룸 "스택","힙"
    - 힙? "객체의 집", 가비지 컬렉션 이 식사하는곳
    - 스택 ? "메소드 호출과 지역변수가 살아가는 곳"
- ### _어디에서 사는지, 얼마나 오랫동안 사는지 아는 것 이 중요하다._

- #### 메소드는 스택에 차곡차곡 쌓인다.

  - 박스를 쌓듯이 쌓여 가장 위에는 현재 실행중인 메소드 가 위치한다.
  - ex) foo(){bar(zar())}
    | zar Running |
    | ------------- |
    | bar Wating |
    | foo Wating |

  - 지역 변수로 들어있는 객체는 그러면 어떻게 되는가 ?
    - 포인터 값만 스택에 들어가고 실제 객체는 힙에 거주 함

- **_핵심정리_**
  - 관심을 가져야할 메모리 공간 "스택","힙"
  - 클래스 안 && 메소드 밖 && 변수 ==> 인스턴스 변수
  - 클래스 안 && 메소드 안 && 변수 ==> 지역변수
  - 모든 지역변수는 스태에 들어있고, 메소드 와 같은 박스에 들어 스택에 쌓임
  - 객체 레퍼런스(포인터 값) 또한 스택에 차곡차곡 쌓임
  - 지역변수 포인터 값인 레퍼런스 변수가 가르키는 객체는 힙에 살아감

## 기적과도 같은 객체 생성

    - 객체 의 3가지 "선언" "생성" "대입"
    - "생성" 에 대해 알아보자

- Duck myDuck = new Duck() ? => 생성자를 호출하는 코드이다.

  - 만든적이 없는데 ? new 를 누가 만들어 주는가 ?
    - 컴파일러 가 마법처럼 자동 생성해준다.
    - 단 우리가 만들지 않았을시에.
  - 어떻게 만드는가 ?
    - 클래스의 이름과 동일한 메서드를 작성하면된다.
  - 컴파일러 에서 자동으로 해주는데 왜 필요한가 ?
    - 객체를 생성시 준비 과정이 필요하다면 필요하다.
    - 불필요하게 메서드를 늘려 함수호출자 에게 불편함을 줄 이유가없다.
  - 이 처럼 생성자를 작성시에는 인자가 없는 생성자도 만들것.

    - 호출자에게 2가지 선택권을 준다.
    - 기본 세팅 을 원하는지, 본인의 커스텀 세팅을 할것인지.

  - 아무리 컴파일러 측에서 생성자를 만들어 준다고 해도 인자가 있는 생성자를 작성시 컴파일러는 이과정을 스킵힌다.
  - **생성자 안의 인자 의 순서가 다를경우 서로다른 생성자임**
    - ex> duck(int Size,boolean fly){...}
    - ex>duck(boolean fly,int Size){...}

- **_핵심정리_**
  - 인스턴스 변수는 객체안에 저장된다.
  - 클래스 사용시 new 키워드를 이용한다면 생성자 라고 한다.
  - 생성자 명은 클래스 명과 같고 리턴유형이 없다.
  - 생성자를 이용하여 객체의 초기 값을 설정할수 있다.
  - 클래스 작성시 생성자를 만들지 않아도 컴파일에서 자동으로 호출해준다.
  - 오버로드된 생성자들의 인자목록은 반드시 달라야한다.

## 객체의 일생에서 상위클래스 생성자의 역할

    - 객체를 생성시 트리안에 있는 모든 생성자는 실행되어야 한다.

```java
// 예시
class Animal {
    Animal() {
        System.out.println("hoit");
    }
}

class Hippo extends Animal {
    Hippo() {
        System.out.println("Houuuu");
    }
}
// in main
Hippo h = new Hippo();
/**
    "hoit"
    "Houuuu";
*/
```

- 상위클래스 생성자는 어떻게 호출할까 ?
  - 하위클래스 생성시 super(); 를 이용해 생성자를 호출할수 있다.
  - 지금까지 super() 를 쓴적이 없는데 ?
    - 컴파일러가 컴파일시 자동으로 넣어줌 다해주네 그냥 짱먹어라
  - 인자가 있다면 ?

```java
public abstract class Animal{
    private String name;
    public Animal(String name){this.name = name;}
}
public class Hippo extends Animal{
    public Hippo(String name){
        super(name);
    }
}
// 이렇게 넘겨주면 된다.
```

## 객체는 얼마나 오래 사는가 ?

    - 레퍼런스 에 의해 좌우 된다.

- 레퍼런스가 죽는다면 그 레퍼런스가 가르키는 개체 또한 죽는다.
- 레퍼런스 변수의 생사는 ?
- 지역변수 or 인스턴스 변수에 따라 달라진다.
  - 지역변수는 그 변수를 선언한 메소드 안에서만 살 수 있다.
  - 인스턴스 변수는 그 객체가 살아있는동안 같이 살아있음(동반자).
